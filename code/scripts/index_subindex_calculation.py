#
# Module with functions to compute VSTOXX sub-indexes
#
# Data as generated by the script index_collect_option_data.py
# is needed for the calculations in this module
#
# (c) Dr. Yves J. Hilpisch
# Listed Volatility and Variance Derivatives
#
import math
import numpy as np
import pandas as pd
import datetime as dt
import index_date_functions as idf
pd.options.mode.chained_assignment = None


def compute_subindex(data, delta_T, R):
    ''' Computes a sub-index for given option series data.

    Parameters
    ==========
    data: pandas.DataFrame object
        contains the option data
    delta_T: float
        time interval
    R: float
        discount factor

    Returns
    =======
    subVSTOXX: float
        sub-index value
    '''
    # difference between put and call option with same strike
    data['Diff_Put_Call'] = np.abs(data.Put_Price - data.Call_Price)
    # converts the strike price which serves as index so far
    # to a regular data column
    data = data.reset_index()
    data['delta_K'] = None
    # differences between the different strikes of the series
    data['delta_K'].iloc[1:-1] = [(data['Strike price'].iloc[i + 1]
            - data['Strike price'].iloc[i - 1]) / 2 for i in data.index[1:-1]]
            # where possible, for the i-th entry it is
            # half of the difference between the (i-1)-th
            # and (i+1)-th price
    #  for i=0 it is just the difference to the next strike
    data['delta_K'].iloc[0] = data['Strike price'].iloc[1] - data['Strike price'].iloc[0]

    data['delta_K'].loc[data.index[-1:]] = float(data['Strike price'].iloc[-1:]) \
            - float(data['Strike price'].iloc[-2:-1])
            # for the last entry, it is just the difference
            # between the second but last strike and the last strike price

    # find the smallest difference between put and call price
    min_index = data.Diff_Put_Call.argmin()

    # the forward price of that option
    forward_price = data['Strike price'].iloc[min_index] \
                    + R * data.Diff_Put_Call[min_index]

    K_0 = data['Strike price'][forward_price -
                                    data['Strike price'] > 0].max()
    # the index of the ATM strike
    K_0_index = data.index[data['Strike price'] == K_0][0]

    # selects the OTM options
    data['M'] = pd.concat((data.Put_Price[0:K_0_index],
                           data.Call_Price[K_0_index:]))

    # ATM we take the average of put and call price
    data['M'].iloc[K_0_index] = (data['Call_Price'][K_0_index]
                            + data['Put_Price'][K_0_index]) / 2

    # the single OTM values
    data['MFactor'] = (R * (data['delta_K'] * data['M'])
                         / (data['Strike price']) ** 2)

    # the forward term
    fterm = 1. / delta_T * (forward_price / K_0 - 1) ** 2
    # summing up
    sigma = 2 / delta_T * np.sum(data.MFactor) - fterm
    subVSTOXX = 100 * math.sqrt(sigma)
    return subVSTOXX


def make_subindex(path):
    ''' Depending on the content of the file 'index_option_series.h5',
    the function computes the sub-indexes V6I1, V6I2 and parts
    of V6I3 and returns a pandas DataFrame object with the results.

    Parameters
    ==========
    path: string
        string with path of data file

    Returns
    =======
    df: pandas DataFrame object
        sub-index data as computed by the function
    '''

    # the data source, created with index_collect_option_data.py
    datastore = pd.HDFStore(path + 'index_option_series.h5', 'r')
    
    max_date = dt.datetime.today()  # find the latest date in the source
    for series in datastore.keys():
        dummy_date = datastore[series].index.get_level_values(0)[0]
        dummy_date = dummy_date.to_pydatetime()
        if dummy_date > max_date:
            max_date = dummy_date
    start_date = dt.datetime.today()  # find the earliest date in the source
    for series in datastore.keys():
        dummy_date = datastore[series].index.get_level_values(0)[0]
        dummy_data = dummy_date.to_pydatetime()
        if dummy_date < start_date:
            start_date = dummy_date
    V1 = dict()  # dicts to store the values, V stands for the sub-indices,
                 # T for their expiry
    V2 = dict()
    V3 = dict()
    T1 = dict()
    T2 = dict()
    T3 = dict()

    # from start_date to max_date, but only weekdays
    for day in pd.bdate_range(start=start_date.date(), end=max_date.date()):
        # is V6I1 defined?
        is_V1_defined = idf.not_a_day_before_expiry(day)
        # the settlement date
        settlement_date = idf.first_settlement_day(day)
        # abbreviation for the expiry date, like Oct14
        key = settlement_date.strftime('%b%y')
        # days until maturity
        delta_T = idf.compute_delta(day, settlement_date)
        try:
            # data of the option series for that date
            data = datastore[key].loc[day]
        except:
            continue

        if is_V1_defined:  # if V6I1 is defined
            # compute its value
            V1[day] = compute_subindex(data, delta_T,
                                       math.exp(0.0015 * delta_T))
            T1[day] = settlement_date
        else:
            # compute the value of V6I2 instead
            V2[day] = compute_subindex(data, delta_T,
                                       math.exp(0.0015 * delta_T))
            T2[day] = settlement_date

        settlement_date_2 = idf.second_settlement_day(day)

        # the same for the next index
        key_2 = settlement_date_2.strftime('%b%y')
        delta_T_2 = idf.compute_delta(day, settlement_date_2)
        data_2 = datastore[key_2].loc[day]

        if is_V1_defined:
            V2[day] = compute_subindex(data_2, delta_T_2,
                                       math.exp(0.001 * delta_T_2))
            T2[day] = settlement_date_2
        else:
            V3[day] = compute_subindex(data_2, delta_T_2,
                                       math.exp(0.001 * delta_T_2))
            T3[day] = settlement_date_2
    
    datastore.close()
    # create the pandas DataFrame object and return it
    df = pd.DataFrame(data={'V6I1': V1, 'Expiry V6I1': T1, 'V6I2': V2,
                    'Expiry V6I2': T2, 'V6I3': V3, 'Expiry V6I3': T3})
    return df

